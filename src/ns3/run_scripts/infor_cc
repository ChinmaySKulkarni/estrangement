/* -*-  Mode: C++; c-file-style: "gnu"; indent-tabs-mode:nil; -*- */
/*
 * Copyright (c) 2011 University of Kansas
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2 as
 * published by the Free Software Foundation;
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program; if not, write to the Free Software
 * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
 *
 * Author: Justin Rohrer <rohrej@ittc.ku.edu>
 *
 * James P.G. Sterbenz <jpgs@ittc.ku.edu>, director
 * ResiliNets Research Group  http://wiki.ittc.ku.edu/resilinets
 * Information and Telecommunication Technology Center (ITTC)
 * and Department of Electrical Engineering and Computer Science
 * The University of Kansas Lawrence, KS USA.
 *
 * Work supported in part by NSF FIND (Future Internet Design) Program
 * under grant CNS-0626918 (Postmodern Internet Architecture),
 * NSF grant CNS-1050226 (Multilayer Network Resilience Analysis and Experimentation on GENI),
 * US Department of Defense (DoD), and ITTC at The University of Kansas.
 */

/* 
 *  Original file created by Justin Rohrer was grid-uniform-traffic.cc
 *  File was modified by Victoria Manfredi, October 2011
 *
 *  Runs OLSR on a degree-4 grid mesh network with random uniform traffic.
 * 
 *  Uses 802.11b as the wifi standard.
 *
 *  The WiFi uses a transmission range of 1000m. A Range Propagation loss model is used so that 
 *  receivers outside of the MaxRange of 1000m do not receive packets.
 *
 *  The simulation runs for 200 simulated seconds, the first 50 seconds are used for start-up time.
 */

#include <fstream>
#include <sstream>
#include <iostream>
#include "ns3/core-module.h"
#include "ns3/network-module.h"
#include "ns3/internet-module.h"
#include "ns3/mobility-module.h"
#include "ns3/wifi-module.h"
#include "ns3/aodv-module.h"
#include "ns3/olsr-module.h"
#include "ns3/dsdv-module.h"
#include "ns3/applications-module.h"
#include "ns3/flow-monitor.h"
#include "ns3/flow-monitor-helper.h"
#include "ns3/flow-monitor-module.h"
#include <time.h>


extern double my_prob[1000];
extern double num_pkts_dropped_aa;
extern double num_pkts_dropped_nr;
extern double num_pkts_forwarded;
extern double num_pkts_replicated;
extern double num_duplicates_dropped;

using namespace ns3;

int total_pkts_rcvd = 0;

NS_LOG_COMPONENT_DEFINE ("ManetRoutingGrid");


//-------------------------------------------------------------------
// Header
//-------------------------------------------------------------------
class RoutingExperiment
{
 
public:

  RoutingExperiment ();
  void Run (int nFlows, double txp, std::string rate); 
  std::string CommandSetup (int argc, char **argv);

private:

  Ptr<Socket> SetupPacketReceive (Ipv4Address addr, Ptr<Node> node);
  void ReceivePacket (Ptr<Socket> socket);
  void CheckThroughput ();

  uint32_t port;
  uint32_t bytesTotal;
  uint32_t packetsReceived;
  uint32_t *packetsReceivedFlow;
  std::string m_CSVfileName;
  int m_nFlows;
  double m_txp;

};


//-------------------------------------------------------------------
// Constructor
//-------------------------------------------------------------------
RoutingExperiment::RoutingExperiment ()
  : port (9),
    bytesTotal (0),
    packetsReceived (0)
{
}



//-------------------------------------------------------------------
// ReceivePacket
//-------------------------------------------------------------------
void
RoutingExperiment::ReceivePacket (Ptr<Socket> socket)
{
  Ptr<Packet> packet;
  while (packet = socket->Recv ())
    {
      bytesTotal += packet->GetSize ();
      packetsReceived += 1;
      SocketAddressTag tag;
      bool found;
      found = packet->PeekPacketTag (tag);
      if (found)
        {
          InetSocketAddress addr = InetSocketAddress::ConvertFrom (tag.GetAddress ());
          std::cout << "@@@@@@@ " << Simulator::Now ().GetSeconds () <<  " " << socket->GetNode ()->GetId ()
                                                         << " received one packet from " << addr.GetIpv4 () << endl << endl;
          Ipv4Address a = addr.GetIpv4();
          int b = a.Get() - 167837696;
          packetsReceivedFlow[b] += 1;
	  total_pkts_rcvd = total_pkts_rcvd + 1; 
          //cast addr to void, to suppress 'addr' set but not used
          //compiler warning in optimized builds
          (void) addr;
        }
      else
        {
          NS_LOG_UNCOND (Simulator::Now ().GetSeconds () << " " << socket->GetNode ()->GetId ()
                                                         << " received one packet!");
        }
    }
}

//-------------------------------------------------------------------
// CheckThroughput
//-------------------------------------------------------------------
void
RoutingExperiment::CheckThroughput ( )
{
  double kbs = (bytesTotal * 8.0) / 1000;
  bytesTotal = 0;

  std::ofstream out (m_CSVfileName.c_str (), std::ios::app);

  out << (Simulator::Now ()).GetSeconds () << ","
      << kbs << ","
      << packetsReceived << ","
      << m_nFlows << ","
      << m_txp << ",";

  for (int i=0; i<m_nFlows; i++)
    {
      out << packetsReceivedFlow[i] << ",";
      packetsReceivedFlow[i] = 0;
    }
  out << std::endl;

  out.close ();
  packetsReceived = 0;

  Simulator::Schedule (Seconds (1.0), &RoutingExperiment::CheckThroughput, this);
}


//-------------------------------------------------------------------
// SetupPacketReceive
//-------------------------------------------------------------------
Ptr<Socket>
RoutingExperiment::SetupPacketReceive (Ipv4Address addr, Ptr<Node> node)
{
  TypeId tid = TypeId::LookupByName ("ns3::UdpSocketFactory");
  Ptr<Socket> sink = Socket::CreateSocket (node, tid);
  InetSocketAddress local = InetSocketAddress (addr, port);
  sink->Bind (local);
  sink->SetRecvCallback (MakeCallback (&RoutingExperiment::ReceivePacket, this));

  return sink;
}


//===================================================================
//
// 
//  Main
//
//===================================================================
int
main (int argc, char *argv[])
{

  time_t startExpTime;
  startExpTime = time(NULL);
  RoutingExperiment experiment;
  num_pkts_dropped_aa = 0;
  num_pkts_dropped_nr = 0;
  num_pkts_forwarded = 0;
  num_pkts_replicated = 0;
  num_duplicates_dropped = 0;
  int nFlows = 10;
  double txp = 7.5;
  
  std::string rate ("8000bps");  // rate at which onoff flow sends data
  int seedNum =  time(NULL);
  int runNum  = 1;

  SeedManager::SetSeed ( seedNum );
  SeedManager::SetRun ( runNum ); 

  experiment = RoutingExperiment ();
  experiment.Run (nFlows, txp, rate);

  time_t finExpTime = time(NULL); 
  std::cout << finExpTime - startExpTime << std::endl;
}

//-------------------------------------------------------------------
// Run
//-------------------------------------------------------------------
void
RoutingExperiment::Run (int nFlows, double txp, std::string rate)
{
  Packet::EnablePrinting ();

  packetsReceivedFlow = new uint32_t[nFlows];
  for (int i=0; i<nFlows; i++)
    {
      packetsReceivedFlow[i] = 0;
    }

  std::string pktSz ("1000");      // bytes in each packet

  std::string pfx ("grid-scaling-output-");
  std::string sfx (".csv");
  std::string dsh ("-");
  std::stringstream s;
  s << pfx << nFlows << dsh << rate << dsh << pktSz << sfx;
  m_CSVfileName = s.str();

  double totalTime     = 8000.0;
  double transientTime = 50.0;
  double cleanUpTime   = 20.0;

  //------------------
  // Set up the nodes
  //------------------

  Ns2MobilityHelper ns2 = Ns2MobilityHelper ("/home/sdabideen/ns3m/ns-allinone-3.13/ns-3.13/scratch/trace.mobility");

  NodeContainer adhocNodes;
  int nWifis = nFlows;
  adhocNodes.Create (nWifis);

  ns2.Install ();
  //--------------------------------------------------
  // Set up the flows, rate at which flows send data
  //--------------------------------------------------
  m_nFlows = nFlows;
  int srcs[nFlows];
  int sinks[nFlows];

  Config::SetDefault ("ns3::OnOffApplication::DataRate",  StringValue (rate));
  Config::SetDefault ("ns3::OnOffApplication::PacketSize", StringValue (pktSz));

    
  //----------------------------------------------------    
  NS_LOG_INFO ("Setting up wifi phy and channel");

  WifiHelper wifi;
  wifi.SetStandard (WIFI_PHY_STANDARD_80211g);
  std::string phyMode =  "ErpOfdmRate54Mbps";


  wifi.SetRemoteStationManager ("ns3::ConstantRateWifiManager",     // Disable rate control 
                                "DataMode",StringValue (phyMode),
                                "ControlMode",StringValue (phyMode));


  YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default ();
  m_txp = txp;
  wifiPhy.Set ("TxPowerStart",DoubleValue (txp));
  wifiPhy.Set ("TxPowerEnd", DoubleValue (txp));

  YansWifiChannelHelper wifiChannel;
  wifiChannel.SetPropagationDelay ("ns3::ConstantSpeedPropagationDelayModel");
  wifiChannel.AddPropagationLoss ("ns3::RangePropagationLossModel", "MaxRange", DoubleValue(0.3 ));
  wifiPhy.SetChannel (wifiChannel.Create ());


  // Add a non-QoS upper mac
  NqosWifiMacHelper wifiMac = NqosWifiMacHelper::Default ();    
  wifiMac.SetType ("ns3::AdhocWifiMac");

  NetDeviceContainer adhocDevices = wifi.Install (wifiPhy, wifiMac, adhocNodes);

  //----------------------------------------------------      
  NS_LOG_INFO ("Setting up routing protocol");
  NS_LOG_INFO ("Install Internet Stack to Nodes.");

  OlsrHelper olsr;
  double mean = 7;
  double rand;

  InternetStackHelper internet;
  for(int i = 0; i < nFlows; i++){
	internet.Reset();
	olsr.Set("HelloInterval", TimeValue (Seconds (2)));
	rand = (int) (-log((double)random()/(double)RAND_MAX)*mean);
	if(rand > 9)
		rand = 9;
	olsr.Set("Willingness",EnumValue (rand));
  	internet.SetRoutingHelper (olsr);
  	internet.Install (adhocNodes.Get(i));
  }

  //----------------------------------------------------    
  NS_LOG_INFO ("Assigning IP Addresses");

  Ipv4AddressHelper addressAdhoc;
  addressAdhoc.SetBase ("10.1.0.0", "255.255.0.0");
  Ipv4InterfaceContainer adhocInterfaces;
  adhocInterfaces = addressAdhoc.Assign (adhocDevices);
  
  for(int i = 0; i < 1000; i++){
	rand = UniformVariable().GetValue(0.85,1.0);
	NS_LOG_UNCOND (rand);
	my_prob[i] = rand;
  }	


 
  //----------------------------------------------------  
  NS_LOG_INFO ("Allocate Positions to Nodes");   
    
//  MobilityHelper mobilityAdhoc;
//  Ptr<RandomRectanglePositionAllocator> posAlloc = CreateObject<RandomRectanglePositionAllocator> ();
//  posAlloc->SetX(RandomVariable(UniformVariable(0,10)));
//  posAlloc->SetY(RandomVariable(UniformVariable(0,10)));
//  mobilityAdhoc.SetPositionAllocator (posAlloc);

//  mobilityAdhoc.SetMobilityModel ("ns3::ConstantPositionMobilityModel");
//  mobilityAdhoc.Install (adhocNodes);

//  Ns2MobilityHelper ns2 = Ns2MobilityHelper ("/home/sdabideen/ns3/ns-allinone-3.13/ns-3.13/scratch/trace.mobility");
//  ns2.Install ();   

 
  //----------------------------------------------------  
  NS_LOG_INFO ("Setup Flows");   

  // Create onoff flow that is always on    
  OnOffHelper onoff1 ("ns3::UdpSocketFactory",Address ());
  onoff1.SetAttribute ("OnTime", RandomVariableValue (ConstantVariable  (1)));
  onoff1.SetAttribute ("OffTime", RandomVariableValue (ConstantVariable (0)));

  // Setup the sources and sinks for each flow
  int i;
  srcs[0] = 3;
  srcs[1] = 5;
  srcs[2] = 8;
  sinks[0] = 9;
  sinks[1] = 9;
  sinks[2] = 9;

  for (int j = 0; j < 3; j++)
    {
      NS_LOG_UNCOND (Simulator::Now ().GetSeconds () <<  " " << srcs[j] << " " << sinks[j]);

      i = sinks[j];
      Ptr<Socket> sink = SetupPacketReceive (adhocInterfaces.GetAddress (i), adhocNodes.Get (i));

      AddressValue remoteAddress (InetSocketAddress (adhocInterfaces.GetAddress (i), port));
      onoff1.SetAttribute ("Remote", remoteAddress);
        
      // Install onoff source at each source
      UniformVariable var;
      ApplicationContainer temp = onoff1.Install (adhocNodes.Get ( srcs[j] )); 
      temp.Start (Seconds (var.GetValue (transientTime, transientTime+1.0)));
      temp.Stop (Seconds (totalTime-cleanUpTime));
    } 

  NS_LOG_UNCOND (" Flows set up\n");
  //----------------------------------------------------  
  NS_LOG_INFO ("Configure Tracing.");

  AsciiTraceHelper ascii;
  std::string sfx2 (".tr");
  std::stringstream s2;
  s2 << pfx << nFlows << dsh << rate << dsh << pktSz << sfx2;
  std::stringstream s3;
  s3 << pfx << nFlows << dsh << rate << dsh << pktSz;
  //wifiPhy.EnableAsciiAll (ascii.CreateFileStream (s2.str()));
  //wifiPhy.EnablePcap (s3.str(), adhocDevices, false);
 

  // Install flow monitor on all nodes    
  FlowMonitorHelper flowmon;
  Ptr<FlowMonitor> monitor = flowmon.InstallAll ();

  //----------------------------------------------------  
  NS_LOG_UNCOND ("Run Simulation.");

  CheckThroughput ();

  
  Simulator::Stop (Seconds (totalTime));
  Simulator::Run ();

  //----------------------------------------------------  
  monitor->CheckForLostPackets ();
  Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier> (flowmon.GetClassifier ());
  std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats ();

  double totalTput        = 0;
  double totalLoad        = 0;
  double totalDelay       = 0;
  double totalSent        = 0;
  double totalRecv        = 0;
  double totalLost        = 0;
  double totalTimesFwd    = 0;

  double totalTputC       = 0;
  double totalLoadC       = 0;
  double totalDelayC      = 0;
  double totalSentC       = 0;
  double totalRecvC       = 0;
  double totalLostC       = 0;
  double totalTimesFwdC   = 0;

  int countflows = 0;
  int countflowsC = 0;

  for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin (); i != stats.end (); ++i)
    {
      Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow (i->first);
      if (t.destinationPort == 9) 
        {
          countflows++;        
          totalLoad     = totalLoad     + i->second.txBytes * 8.0; // bits
          totalTput     = totalTput     + i->second.rxBytes * 8.0; // bits
          totalDelay    = totalDelay    + i->second.delaySum.GetDouble(); // ns per pkt
          totalSent     = totalSent     + (double)i->second.txPackets;   
          totalRecv     = totalRecv     + (double)i->second.rxPackets;  
          totalLost     = totalLost     + (double)i->second.lostPackets;   
          totalTimesFwd = totalTimesFwd + (double)i->second.timesForwarded; // forward per packet

        }
      else
        {
          countflowsC++;        
          totalLoadC     = totalLoadC     + i->second.txBytes * 8.0; // bits
          totalTputC     = totalTputC     + i->second.rxBytes * 8.0; // bits
          totalDelayC    = totalDelayC    + i->second.delaySum.GetDouble(); // ns per pkt
          totalSentC     = totalSentC     + (double)i->second.txPackets;   
          totalRecvC     = totalRecvC     + (double)i->second.rxPackets;  
          totalLostC     = totalLostC     + (double)i->second.lostPackets;   
          totalTimesFwdC = totalTimesFwdC + (double)i->second.timesForwarded; // forward per packet
      }
    }

  int total_recvd = 0;
  for (int i=0; i<m_nFlows; i++)
    {
      total_recvd += packetsReceivedFlow[i];
    }
  ofstream res("results",ios::app);

  std::cout << totalSent << " " << totalRecv << " " << totalDelay << "\n";
  res << totalSent << " " << totalRecv << " " << totalDelay << "\n";
  cout << "total num of pkts forwarded " << num_pkts_forwarded << endl;
  res << "total num of pkts forwarded " << num_pkts_forwarded << endl;
  cout << "total pkts dropped due to AA: " << num_pkts_dropped_aa << endl;
  res << "total pkts dropped due to AA: " << num_pkts_dropped_aa << endl;
  cout << "total pkts dropped due to No Route: " << num_pkts_dropped_nr << endl;
  res << "total pkts dropped due to No Route: " << num_pkts_dropped_nr << endl;
  cout << "total number of replications: " << num_pkts_replicated << " " <<  endl;
  res << "total number of replications: " << num_pkts_replicated << " " <<  endl;
  cout << "total pkts lost: " << totalLost << endl;
  res << "total pkts lost: " << totalLost << endl;
  cout << "num duplicates dropped: " << num_duplicates_dropped << endl;
  res << "num duplicates dropped: " << num_duplicates_dropped << endl;
  cout << "fwd per packet: " << totalTimesFwdC << endl;
  cout << "total recvd at dest: " << total_pkts_rcvd << endl;
  res << "total recvd at dest: " << total_pkts_rcvd << endl;
  //----------------------------------------------------  
  res.close();
  Simulator::Destroy ();
}

